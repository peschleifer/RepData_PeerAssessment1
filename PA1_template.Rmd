---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---


## Loading and preprocessing the data

Make sure we have the needed packages loaded - this analysis requires dplyr, lattice and ggplot2
```{r libs,results='hide',message=FALSE}
if ( !(require(dplyr) && require(lattice) && require(ggplot2)) ) {
    stop ("You need to install the dplyr, lattice and ggplot2 packages to run this script")
}
```

Unzip and read the activity data file. Convert the date column into a date. Keep the interval column as a number, we will add a date representaiton as needed for plotting
```{r}
actMonRaw <- read.csv( unz('activity.zip','activity.csv'))
actMon <- tbl_df(actMonRaw) %>%
    mutate( date = as.Date(date) ) 
```

## What is mean total number of steps taken per day?
Calculate the number of steps taken each day by taking the sum of the number of steps in each 5 minute interval during the day. Missing values are ignored in this part.
```{r}
dailySteps <- actMon %>%
    group_by( date ) %>%
    summarize( steps = sum(steps, na.rm=TRUE) )
```

Let's see a histogram of the number of steps per day
```{r stepsRawHistorgram,echo=FALSE}
qplot( steps, data=dailySteps, xlab="Daily Steps", binwidth=max(dailySteps$steps)/50 ) + geom_vline(xintercept=mean(dailySteps$steps), color="green", linetype="longdash")
```

The mean number of steps taken each day is `r sprintf("%.2f", mean(dailySteps$steps))` (shown above). The median is `r median(dailySteps$steps)`. For calculating these numbers, the number of steps on days with no readings is 0. if we exclude those days the results are `r sprintf("%.2f", mean(dailySteps$steps[dailySteps$steps>0]))` for the mean and `r median(dailySteps$steps[dailySteps$steps>0])` for the median.


## What is the average daily activity pattern?

Find the average number of steps in each 5 minute interval, ignoring missing values.
We'll count the number of days data was actually collected for each interval, and use that in the average.
```{r}
intervalSteps <- actMon %>%
    group_by( interval ) %>%
    summarize( daysCollected = sum(!is.na(steps)), steps = sum(steps, na.rm=TRUE) )
intervalSteps$intervalTime=strptime( sprintf("%04d",intervalSteps$interval),  format="%H%M")
```

The average steps within each interval

```{r stepsWithinInterval,echo=FALSE}
with( intervalSteps, plot( intervalTime, 
                           steps/daysCollected, 
                           type="l", 
                           xlab="Interval Start Time",
                           ylab="Average steps in 5-minute interval"))
```

The interval that contains, on average, the maximum number of steps starts at 
`r format(intervalSteps[with(intervalSteps, which.max(steps/daysCollected) ),4], "%H:%M")`.

## Imputing missing values

There are `r sum(is.na(actMon$steps))` missing values for the step counts. This represents
`r sprintf("%.2f%%",100*sum(is.na(actMon$steps))/length(actMon$steps))`
of the data. How do these missing values impact the data? Extracting just the missing values:
```{r}
missing <- actMon[is.na(actMon$steps),]
```
```{r missingValuesByInterval,echo=FALSE}
hist(missing$interval/100, xlab="Hour", main="Distribution of missing values by hour", breaks=24,xaxp=c(0,24,4))
```

We observe that the missing values are distributed evenly thoughout the day, with only a slight variation around midnight (when the number of steps is low), so the missing values are assumed to not significantly affect the distribution of steps thoughout the day. How do the missing values distribute over the days?

```{r missingValuesByDay,echo=FALSE}
hist(missing$date, xlab="Date", main="Distribution of missing values by day", breaks=length(missing$date),freq=TRUE)
```

Most days do not have any missing values, the ones that do are missing the same number - possibly all 288 of them. We can see the numbers:

```{r}
table(missing$date)
```

On the above 8 days no measurements are available. The other days are not missing any readings. This suggests a smoothing, using the mean of the neighboring days, will give reasonable values to impute the missing data - except there are two conditions which prevent such a simple approach:

1. There may be (and in fact, are) two consecutive dates with missing data. To handle this situation, our rule is to take the days before and after, skipping over days with missing data
1. A day with missing data may be (and in fact, is) the first or last day for data collection. These days may be discarded, since imputing values here would add nothing.

Since we know that if any reading is missing for a day, then all the readings are missing for that day, we can simplify the processing. We start with the boundary conditions, removing rows for the first and last dates until these are not missing the steps reading. The code is also simplified because we know that the data frame is in date order.

First we will copy into a new fram and remove the days at boundaries of the date range where no readings were collected

```{r}
actMonImp <- actMon
while ( is.na(actMonImp[1,1]) ) { 
    removeDate <- actMonImp[1,2]
    actMonImp <- actMonImp[!(actMonImp$date==removeDate[[1]]),]
}
while ( is.na(actMonImp[dim(actMonImp)[1],1]) ) { 
    removeDate <- actMonImp[dim(actMonImp)[1],2]
    actMonImp <- actMonImp[!(actMonImp$date==removeDate[[1]]),]
}
```

Then we will smooth the remaining missing data with the mean of the readings from the nearest days before and day after that have actual readings. To help with this we will create a vector containing the dates with missing data that we need to impute.

```{r}
missingDays <- unique(actMonImp[is.na(actMonImp[,1]),2])[[1]]
```

Define a helper function to make the code a little clearer. This will return the date with non-missing data closest to the specified date in the indicated direction.

```{r}
dayWithData <- function( df, d, dir ) {
    while ( is.na(df[df$date==d & df$interval==0,1]) ) {
        d = d + dir*1
    }
    
    d
}
```

Loop through the days with missing data and impute using the means of the neighbors. Note that the original (non-imputed) frame is used to determine the neighboring days to use - this avoids having the results affected by application of this step to a prior day in the loop.

```{r}
for (d in 1:length(missingDays) ) {
    dayBefore <- dayWithData( actMon, missingDays[d], -1 )
    dayAfter <-  dayWithData( actMon, missingDays[d], +1 )
    actMonImp[actMonImp$date==missingDays[d],]$steps =
        (actMonImp[actMonImp$date==dayBefore,]$steps +
        actMonImp[actMonImp$date==dayAfter,]$steps) / 2
}
```

Now make a histogram with the imputed data included and compare the mean and median with the original results. First we need to recalculate the daily totals.

```{r}
dailySteps <- actMonImp %>%
    group_by( date ) %>%
    summarize( steps = sum(steps, na.rm=TRUE) )
```

The histogram of the number of steps per day with the imputed data

```{r stepsImputedHistorgram,echo=FALSE}
qplot( steps, data=dailySteps, xlab="Daily Steps", binwidth=max(dailySteps$steps)/50 ) + geom_vline(xintercept=mean(dailySteps$steps), color="green", linetype="longdash")
```

The spike at 0, which was due to the missing data causing the affected days to show a zero total, is gone. The mean number of steps taken each day is `r sprintf("%.2f", mean(dailySteps$steps))` (shown above). The median is `r sprintf("%d", median(dailySteps$steps))`. These are closer to the original values with the missing days excluded than with those daily totals being with as 0, as would be expected.

## Are there differences in activity patterns between weekdays and weekends?

Continuing to work with the dataset which includes the imputed missing values, create a new factor variable in the dataset with two levels - "weekday" and "weekend" indicating whether a given date is a weekday or weekend day. Find the average number of steps in each 5 minute interval, grouped by weekdays and weekends. We know, since we imputed all the missing values, that there are no NA's and there is no variation in the number of days data was collected within the weekday and weekend readings, so we only need two number for the denominators

```{r}
actMonImp$dayType <- factor(
    ifelse( 
        weekdays(actMonImp$date, abbreviate=TRUE) %in% c('Sat','Sun'), 
        'weekend', 
        'weekday'
        ) 
    )

intervalSteps <- actMonImp %>%
    group_by( dayType, interval ) %>%
    summarize( steps = sum(steps) )
intervalSteps$intervalTime=strptime( sprintf("%04d",intervalSteps$interval),  format="%H%M")

daysCollected <- unique(actMonImp[,c(2,4)]) %>%
    group_by(dayType) %>%
    summarize(numberDays=length(date))
```

Let's see how the daily activity patterns compares between weekdays and weekends:

```{r stepsByDaytype,echo=FALSE}
xyplot( steps/daysCollected$numberDays[unclass(dayType)] ~ interval | dayType, 
        data=intervalSteps, 
        type="l", 
        xlab="Interval",
        ylab="Number of steps",
        layout=c(1,2) )
```